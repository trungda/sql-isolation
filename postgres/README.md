# Isolation Levels in PostgresSQL
Examples are from the book [PostgresSQL 14 Internals][1].
More details about individual isolation level can be found from the book and [Postgres official document][2].

| Isolation Level   | Dirty Read   | Nonrepeatable Read | Phantom Read | Other Anomalies |
| ----------------- | ------------ | ------------------ | ------------ | --------------- |
| Read Committed    | No           |   Yes              |   Yes        | Yes             |
| Repeatable Read   | No           |   No               |   No         | Yes             |
| Serializable Read | No           |   No               |   No         | No              |



## Isolation Level: Read Committed

### Anomalies
* Disallow: dirty reads; 
* Allow: everything else;

### Example 1

#### Initial state
```sql
test=*# CREATE TABLE accounts(
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    client text,
    amount numeric
);

test=*# INSERT INTO accounts VALUES (1, 'alice', 1000.00), (2, 'bob', 100.00), (3, 'bob', 900.00);

test=*# SELECT * FROM accounts;
 id | client | amount                                                                                            
+----+--------+---------                                                                                            
  1 | alice  | 1000.00
  2 | bob    |  100.00
  3 | bob    |   900.0 

test=# SHOW default_transaction_isolation;
 default_transaction_isolation 
-------------------------------
 read committed
(1 row)
```

#### TXN 1
```sql
test=*# BEGIN;
test=*# UPDATE accounts SET amount = amount - 200 WHERE id = 1;
UPDATE 1
test=*# SELECT * FROM accounts;
 id | client | amount 
----+--------+--------
  2 | bob    | 100.00
  3 | bob    |  900.0
  1 | alice  | 800.00 <-- Notice this has changed.
(3 rows)

```
#### TXN 2
```sql
BEGIN;
test=# begin;
BEGIN
test=*# select * from accounts;
 id | client | amount  
----+--------+---------
  1 | alice  | 1000.00
  2 | bob    |  100.00
  3 | bob    |   900.0 <-- Notice this hasn't changed from the original value.
(3 rows)
```

#### TXN 1
```
test=*# COMMIT;
COMMIT
```

#### TXN 2
```sql
test=*# select * from accounts;
 id | client | amount 
----+--------+--------
  2 | bob    | 100.00
  3 | bob    |  900.0
  1 | alice  | 800.00 <-- Notice TXN 2 has now seen the committed value from TXN 1. This is a non-repeatable read.
(3 rows)
test=*# COMMIT;
COMMIT;
```

## Isolation Level: Repeatable Read
Anomalies:
* Disallow: non-repeatable read;
* Allow: Other anomalies, such as write-skew, read-only transaction;

### Example 1: Repeatable read
#### Initial state
```sql
test=# SELECT * FROM accounts;
 id | client | amount 
----+--------+--------
  2 | bob    | 100.00
  3 | bob    |  900.0
  1 | alice  | 800.00
(3 rows)
```

#### TXN 1
```sql
test=# BEGIN;
BEGIN
test=*# UPDATE accounts SET amount = 200.00 WHERE id = 2;
UPDATE 1
test=*# INSERT INTO accounts VALUES (4, 'charlie', 100.0);
INSERT 0 1
```
#### TXN 2
```sql 
test=# BEGIN ISOLATION LEVEL REPEATABLE READ;
BEGIN
test=*# SELECT * FROM accounts;
 id | client | amount 
----+--------+--------
  3 | bob    |  900.0
  1 | alice  | 800.00
  2 | bob    | 100.00
(3 rows)
```

#### TXN 1
```sql
test=*# COMMIT;
COMMIT
```

#### TXN 2
```sql
test=*# SELECT * FROM accounts;
 id | client | amount 
----+--------+--------
  3 | bob    |  900.0
  1 | alice  | 800.00
  2 | bob    | 100.00
-- Notice the result is the same with previous operator in the same 
-- transaction (TXN 2) even though TXN 1 has committed. 

test=*# COMMIT;
COMMIT
```

### Example 2: Serialization error

#### Initial state
```sql
test=# SELECT * FROM accounts; 
 id | client  | amount 
----+---------+--------
  3 | bob     |  900.0
  1 | alice   | 800.00
  2 | bob     | 200.00
  4 | charlie |  100.0
(4 rows)
```
#### TXN 1
```sql
test=# BEGIN;
BEGIN
test=*# UPDATE accounts SET amount = amount - 100 WHERE id = 3;
UPDATE 1
```

#### TXN 2
```sql
test=# BEGIN ISOLATION LEVEL REPEATABLE READ;
BEGIN
test=*# UPDATE accounts SET amount = amount * 1.01 WHERE client IN (SELECT client FROM accounts GROUP BY client HAVING sum(amount) >= 1000.00);
-- hanging...waiting for TXN 1 to commit as it's holding the lock for row id = 3;
```

#### TXN 1
```sql
test=*# COMMIT;
COMMIT
```

#### TXN 2
```sql
ERROR:  could not serialize access due to concurrent update
test=!# ROLLBACK;
ROLLBACK
```

### Example 3: Write skew
#### Initial state
```sql
test=# SELECT * FROM accounts; 
 id | client  | amount 
----+---------+--------
  1 | alice   | 800.00
  2 | bob     | 200.00
  4 | charlie |  100.0
  3 | bob     |  800.0
(4 rows)
```

#### TXN 1
```sql
test=# BEGIN ISOLATION LEVEL REPEATABLE READ;
BEGIN
test=*# SELECT SUM(amount) FROM accounts WHERE client = 'bob';
   sum   
---------
 1000.00
(1 row)
```

#### TXT 2
```sql
test=# BEGIN ISOLATION LEVEL REPEATABLE READ;
BEGIN
test=*# SELECT SUM(amount) FROM accounts WHERE client = 'bob';
   sum   
---------
 1000.00
(1 row)
```

#### TXN 1
```sql
test=*# UPDATE accounts SET amount = amount - 600 WHERE id = 2;
UPDATE 1
test=*# COMMIT;
```

#### TXN 2
```sql
test=*# UPDATE accounts SET amount = amount - 600 WHERE id = 3;
UPDATE 1
test=*# COMMIT;
```

#### Final state
```
test=# SELECT * FROM accounts;
 id | client  | amount  
----+---------+---------
  1 | alice   |  800.00
  4 | charlie |   100.0
  2 | bob     | -400.00
  3 | bob     |   200.0
(4 rows)

-- We would hope that either TXN 1 or TXN 2 would fail to overdraft either Bob's accounts to prevent
-- the sum of Bob's accounts to go below zero.
```
## Isolation Level: Serializable
### Anomalies
* Allow: Nothing;
* Disallow: Everything;
### Example 1: No write skew
#### TXN 1
```sql
test=# BEGIN ISOLATION LEVEL SERIALIZABLE;
BEGIN
test=*# SELECT SUM(amount) FROM accounts WHERE client = 'bob';
   sum   
---------
 1000.00
(1 row)

test=*# UPDATE accounts SET amount = amount - 600 WHERE id = 2;
UPDATE 1
```

#### TXN 2
```sql
test=# BEGIN ISOLATION LEVEL SERIALIZABLE;
BEGIN
test=*# SELECT SUM(amount) FROM accounts WHERE client = 'bob';
   sum   
---------
 1000.00
(1 row)

test=*# UPDATE accounts SET amount = amount - 600 WHERE id = 3;
UPDATE 1

test=*# COMMIT;
COMMIT
```

#### TXN 1
```sql
test=*# COMMIT;
ERROR:  could not serialize access due to read/write dependencies among transactions
DETAIL:  Reason code: Canceled on identification as a pivot, during commit attempt.
HINT:  The transaction might succeed if retried.
```

[1]: https://postgrespro.com/community/books/internals
[2]: https://www.postgresql.org/docs/14/transaction-iso.html